<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#documentary-for-bcnetwork-simulation-related-codes.">Documentary for BCNetwork simulation related Codes.</a><ul>
<li><a href="#biochemical-models-storage-and-conversion">Biochemical models storage and conversion</a><ul>
<li><a href="#bcnetwork-class-template">BCNetwork Class Template</a></li>
<li><a href="#modelloadder-class-template">modelLoadder Class Template</a></li>
<li><a href="#odenetwork-class">ODENetwork Class</a></li>
</ul></li>
<li><a href="#coarse-grained-model-module">Coarse Grained Model module</a><ul>
<li><a href="#reaction-network-format">Reaction network format</a></li>
<li><a href="#reaction-structure">reaction structure</a></li>
<li><a href="#trajectory-structure-template">trajectory structure template</a></li>
<li><a href="#coarse-grained-model-class-template.">coarse grained model class template.</a></li>
<li><a href="#coarse-grained-stochastic-class">Coarse Grained Stochastic class</a></li>
</ul></li>
<li><a href="#algorithms">Algorithms</a><ul>
<li><a href="#outdated-gillespie-algorithmgillespiestandalone">Outdated Gillespie Algorithm(gillespieStandAlone)</a></li>
<li><a href="#gillespie-algorithm-class-template">Gillespie Algorithm class template</a></li>
<li><a href="#odeivpcommon-class-template">ODEIVPCommon Class Template</a></li>
<li><a href="#rkmethod-class-template">RKmethod Class Template</a></li>
</ul></li>
<li><a href="#user-facing-modules-for-biochemical-network-simulation">User facing modules for Biochemical Network simulation</a><ul>
<li><a href="#odesimulate-class">ODESimulate Class</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="documentary-for-bcnetwork-simulation-related-codes."><a href="#documentary-for-bcnetwork-simulation-related-codes.">Documentary for BCNetwork simulation related Codes.</a></h1>
<p>Purpose of this article is to create an index for the classes and modules defined in the projects. And guide the future development based on the work.</p>
<p>Note that the css file used for this README article is one of the css files hosted on <a href="https://github.com/jasonm23/markdown-css-themes" title="jasonm23/markdown-css-themes">Github</a>.</p>
<h2 id="biochemical-models-storage-and-conversion"><a href="#biochemical-models-storage-and-conversion">Biochemical models storage and conversion</a></h2>
<h3 id="bcnetwork-class-template"><a href="#bcnetwork-class-template">BCNetwork Class Template</a></h3>
<p>defined in &quot;BCNetwork.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> compType, <span class="kw">typename</span> rateType, <span class="kw">typename</span> powerType&gt;
<span class="kw">class</span> BCNetwork</code></pre>
<p>This module is the basic module to store the information necessary to describe a biochemical network. It is supposed to be able to handle all types of biochemical networks(from elemental to huge, both discrete and continuous.)</p>
<table>
<thead>
<tr class="header">
<th align="left">typename</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>compType</code></td>
<td align="left">data type of the amount of reactants</td>
</tr>
<tr class="even">
<td align="left"><code>rateType</code></td>
<td align="left">data type of the reactant constants</td>
</tr>
<tr class="odd">
<td align="left"><code>powerType</code></td>
<td align="left">data type of both rate matrix and update matrix</td>
</tr>
</tbody>
</table>
<h4 id="public-variable-members"><a href="#public-variable-members">Public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double t</code></td>
<td align="left">current time of the network</td>
</tr>
<tr class="even">
<td align="left"><code>int nComp</code></td>
<td align="left">number of reactants</td>
</tr>
<tr class="odd">
<td align="left"><code>compType * comp</code></td>
<td align="left">pointer to datablock that store amount of each reactants</td>
</tr>
<tr class="even">
<td align="left"><code>compType * compBackup</code></td>
<td align="left">same as <code>comp</code>, a back up datablock for resetting purpose</td>
</tr>
<tr class="odd">
<td align="left"><code>int nRate</code></td>
<td align="left">number of rate constants</td>
</tr>
<tr class="even">
<td align="left"><code>rateType * rate</code></td>
<td align="left">pointer to datablock that store each rate constants</td>
</tr>
<tr class="odd">
<td align="left"><code>powerType * rateMatrix</code></td>
<td align="left">pointer to datablock for rate matrix. Format: <code>i*nComp+j</code></td>
</tr>
<tr class="even">
<td align="left"><code>powerType * updateMatrix</code></td>
<td align="left">pointer to datablock for update matrix. Format, as above.</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members"><a href="#public-function-members">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> loadParameter(vector&lt;compType&gt; &amp;, vector&lt;rateType&gt; &amp;, powerType *, powerType *);</code></pre>
<p>Load parameter from a certain model. Four types of parameters required to fully describe a model are required. the four inputs are respectively : amount of reactants as a form of vector; amount of rate constants as a form of vector; rate matrix as a datablock of same format as described in variable members; update matrix as a datablock of same requirement.</p>
<p>loadParameter will import all the information obtained from the input into the inbuilt dataset. So the destruction of input source after the import will not disturb the funtion of this modules or any modules that inherit from it.</p>
<p>Importing a second network will overwrite the previous one stored in. The previous network will be automatically completely erased before a second network is written in, so backup is suggested before this action.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> fileOpen(string &amp; condition);
<span class="dt">int</span> fileClose();</code></pre>
<p>Open and close a data saving file. <code>fileOpen(string &amp;)</code> will open a data file with name &quot;./result/sim$(condition)&quot;. New file will be created if it is not exist. And older data willed be wiped in the file with a same name. Note that new folder won't be created if not exist. So a folder &quot;result&quot; created under the working directory before running the code is suggested.</p>
<p>Note that the folder name &quot;./result/&quot; is defined in &quot;basicDef.h&quot; as</p>
<pre><code>#define RESULTFOLDER &quot;./result/&quot;</code></pre>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">void</span> saveData();</code></pre>
<p>Essentially this function will toss a copy of the current time and amount of each reactants into the data file opened by <code>int fileOpen(string &amp;)</code>. Data will be saved in a file named &quot;./result/simEmergency&quot; if no file is opened. But open a file before saving the data is still suggested.</p>
<p>Note that this member function covers only the basic saving feature and changable in classes inherit this class template.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">void</span> reset();</code></pre>
<p>Restore the datablock that <code>* comp</code> pointing to with the datablock pointed by <code>* compBackup</code>. And again, this member function is preliminary and changable in classed derived from this class template.</p>
<h4 id="constructor-and-destructor"><a href="#constructor-and-destructor">Constructor and Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">BCNetwork();
BCNetwork(vector&lt;compType&gt; &amp; initComp, vector&lt;rateType&gt; &amp; inputRate, 
             powerType * inputRateMatrix, powerType * inputUpdateMatrix);
~BCNetwork();</code></pre>
<p><code>BCNetwork()</code> only setting private members to correct initial value for the class to function correctly. <code>BCNetwork(vector&lt;compType&gt; &amp;, vector&lt;rateType&gt; &amp;, powerType *, powerType *)</code> will call <code>int loadParameter(...)</code> to load a model when initiating the class. <code>~BCNetwork()</code> will free all memory that allocated from this class template before its destruction.</p>
<h3 id="modelloadder-class-template"><a href="#modelloadder-class-template">modelLoadder Class Template</a></h3>
<p>defined in &quot;modelLoader.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> compType, <span class="kw">typename</span> rateType, <span class="kw">typename</span> powerType &gt;
<span class="kw">class</span> modelLoader</code></pre>
<p>This class template is merely used to load a model from file. The use of this class is temporary before it's function incorporated into <code>BCNetwork</code> class template.</p>
<h4 id="public-function-members-1"><a href="#public-function-members-1">public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> loadParameter(string &amp; mName);</code></pre>
<p>This is the only functional member. It's used to load model parameters stored in folder &quot;./mName&quot;. The format of model parameters will be specified in a model creation/modification project. To completely load a model, four files will be read. The name of them are specified as macros stored in &quot;basicDef.h&quot;:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define RATEFILE &quot;rate&quot;     </span><span class="co">// reaction rate constants, first line is the number of reactions</span>
<span class="ot">#define INITCONDFILE &quot;initCond&quot;     </span><span class="co">//initial condition for each reactants, first line is  </span>
                                    <span class="co">//the number of reactants</span>
<span class="ot">#define RATEMATRIXFILE &quot;rMatrix&quot;    </span><span class="co">//rate matrix, same format as in datablock</span>
<span class="ot">#define UPDATEMATRIXFILE &quot;updMatrix&quot;    </span><span class="co">//update matrix, same format as in datablock</span></code></pre>
<h4 id="constructordestructor"><a href="#constructordestructor">Constructor/Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">modelLoader(string &amp; mName);
~modelLoader();</code></pre>
<p><code>modelLoader(string &amp;)</code> calls <code>loadParameter(string &amp;)</code>. This is the only valid way of initiating modelLoader class. Other ways of initiating this class may involve unexpected behavior.</p>
<h3 id="odenetwork-class"><a href="#odenetwork-class">ODENetwork Class</a></h3>
<p>defined in &quot;ODECommon.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ODENetwork : <span class="kw">public</span> BCNetwork&lt;<span class="dt">double</span>, <span class="dt">double</span>, <span class="dt">int</span>&gt;</code></pre>
<p>This is the basic class for biochemical networks described by ODEs. In addition to the features already defined in <code>BCNetwork</code>class template, the ODEs required for simulation and time variable will be defined in this class. But neither simulation nor analysis feature is defined in this class.</p>
<p>These chemical networks are defined in continuous space and are deterministic. Thus both reactant amount datatype and reaction rate datatype are double.</p>
<p>Note, the two matrices in most cases are integer, thus the powerType is defined so. For specific cases that require non-integer powerType, change the type accordingly.</p>
<h4 id="protected-member"><a href="#protected-member">Protected member</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double h0</code></td>
<td align="left">initial size of time step</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-2"><a href="#public-function-members-2">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ODETimeDeri(<span class="dt">double</span> * timeDeri, <span class="dt">double</span> * component);</code></pre>
<p>This is the ODEs generated from the biochemical network. The usage of the ODEs is to feed 2 pointers to the function. <code>* component</code> point to the datablock of current reactant amounts; <code>*timeDeri</code> point to the datablock that stores the time derivations of each reactants' amount.</p>
<p>Note that the datablock pointed by timeDeri will be changed after this function is called. Backup is suggested if there is anything you don't want to be erased there.</p>
<h4 id="constructor-destructor"><a href="#constructor-destructor">Constructor/ Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ODENetwork(vector&lt;<span class="dt">double</span>&gt; &amp; initComp, vector&lt;<span class="dt">double</span>&gt; &amp; inputRate, 
            <span class="dt">int</span> * inputRateMatrix, <span class="dt">int</span> * inputUpdateMatrix, <span class="dt">double</span>                              
            initTimeStep) :   
            BCNetwork&lt;<span class="dt">double</span>,<span class="dt">double</span>,<span class="dt">int</span>&gt;
            (initComp, inputRate, inputRateMatrix, inputUpdateMatrix);</code></pre>
<p>Well, basically it's self explined. It does two things. It calls the constructor that loads a biochemical network, and give <code>h0</code> an initial value given by user.</p>
<h2 id="coarse-grained-model-module"><a href="#coarse-grained-model-module">Coarse Grained Model module</a></h2>
<h3 id="reaction-network-format"><a href="#reaction-network-format">Reaction network format</a></h3>
<p>Reaction network will be stored as a folder named by the network name. In the folder, there will be 2 files, <code>reaction</code> and <code>reactant</code>. In <code>reactant</code>, initial values of all relative reactants is to be stored respectively. Number of values will be treated as the number of reactants. In <code>reaction</code>, all reactions in the network is to be stored respectively. Format of reactions is as followed:</p>
<p><code>code</code> <code>rate_0</code> <code>rate_1</code> <code>rate_2</code> <code>rate_3</code> <code>dep_0</code> <code>dep_1</code> <code>dep_2</code> <code>upd_num</code> <code>upd_0</code> <code>upd_1</code> <code>upd_2</code></p>
<p>where each <code>xxx</code> represent a value/group of values, either integer or decimal. Meaning of them are as following:</p>
<table>
<thead>
<tr class="header">
<th align="left">name</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>code</code></td>
<td align="left"><code>int</code>, used to identify reaction type</td>
</tr>
<tr class="even">
<td align="left"><code>rate_0~3</code></td>
<td align="left"><code>float</code>, store reaction constants. Depending on reaction type,<br> not all 4 of them are necessarily meaningful.</td>
</tr>
<tr class="odd">
<td align="left"><code>dep_0~2</code></td>
<td align="left"><code>int</code>, store reaction rate dependency on reactants. <br>Each int represents the serial of the respective reactant.<br> Depending on reaction type,<br> not all 3 of them are necessarily meaningful.</td>
</tr>
<tr class="even">
<td align="left"><code>upd_num</code></td>
<td align="left"><code>int</code> ranged from <code>0~3</code>, number of reactants to be updated.</td>
</tr>
<tr class="odd">
<td align="left"><code>upd_0~2</code></td>
<td align="left"><code>int &lt;tab&gt; double</code>, store the serial number and number of <br> molecules change by each instance of reaction. <br> Dependingon <code>upd_num</code>,<br> not all 3 of them are necessarily meaningful.</td>
</tr>
</tbody>
</table>
<p>Though not necessary, it is recommended that one line is to store the information of one reaction.</p>
<p>In coarse grained model, we describe the reactions into 5 types. Those reaction types should be able to describe almost all reactions seen in reaction networks, the following table is the storage format of each reaction type.</p>
<table>
<thead>
<tr class="header">
<th align="left">type</th>
<th align="left"><code>code</code></th>
<th align="left"><code>rate_0~3</code></th>
<th align="left"><code>dep_0~2</code></th>
<th align="left"><code>upd_num</code></th>
<th align="left"><code>upd_0~2</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>*-&gt;..</code></td>
<td align="left">0</td>
<td align="left"><code>k rand rand rand</code></td>
<td align="left"><code>rand rand rand</code></td>
<td align="left"><code>r. spec.</code></td>
<td align="left"><code>r. spec.</code></td>
</tr>
<tr class="even">
<td align="left"><code>A-&gt;..</code></td>
<td align="left">1</td>
<td align="left"><code>k rand rand rand</code></td>
<td align="left"><code>A rand rand</code></td>
<td align="left"><code>r. spec.</code></td>
<td align="left"><code>r. spec.</code></td>
</tr>
<tr class="odd">
<td align="left"><code>A+B-&gt;..</code></td>
<td align="left">2</td>
<td align="left"><code>k rand rand rand</code></td>
<td align="left"><code>A B rand</code></td>
<td align="left"><code>r. spec.</code></td>
<td align="left"><code>r. spec.</code></td>
</tr>
<tr class="even">
<td align="left">MM kinetics</td>
<td align="left">3</td>
<td align="left"><code>k K rand rand</code></td>
<td align="left"><code>S E rand</code></td>
<td align="left"><code>r. spec.</code></td>
<td align="left"><code>r. spec.</code></td>
</tr>
<tr class="odd">
<td align="left">Hill equa.</td>
<td align="left">4</td>
<td align="left"><code>k K n rand</code></td>
<td align="left"><code>P factor rand</code></td>
<td align="left"><code>r. spec.</code></td>
<td align="left"><code>r. spec.</code></td>
</tr>
</tbody>
</table>
<p>Note:</p>
<pre><code>1.  Update reactants are case by case specific, thus not described here.

2.  The four cases defined here are the four standard cases defined in 
    `class coarseGrainedModel&lt;compType, updRateType&gt;`.

3.  Hill equation usually follows some other reaction, here we define only the case
    that combined protein being able to trigger some type `1` reaction with rate `k`.
    The equilibrium constant of factor combining is `K`.

4.  New reaction types can be added, as described in
    `class coarseGrainedModel&lt;compType, updRateType&gt;`.</code></pre>
<h3 id="reaction-structure"><a href="#reaction-structure">reaction structure</a></h3>
<p>defined in &quot;coarseGrainedCommon.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> reaction</code></pre>
<p>This structure is to store the information used to describe one reaction in coarse grained models.</p>
<h4 id="public-variable-members-1"><a href="#public-variable-members-1">Public variable members</a></h4>
<p>Note: It is not suggested for reactions to be modified after loaded from file, but on necessary occations, the following will serve a guide on the format information stored in the structure.</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>int code</code></td>
<td align="left">code to identify the reaction type</td>
</tr>
<tr class="even">
<td align="left"><code>double rate[MAXRATECOEF]</code></td>
<td align="left">rate coefficients of the reaction</td>
</tr>
<tr class="odd">
<td align="left"><code>int dependency[MAXDEPENDENCY]</code></td>
<td align="left">reactant dependency of the reaction rate</td>
</tr>
<tr class="even">
<td align="left"><code>int updateNumber</code></td>
<td align="left">number of reactant to be updated</td>
</tr>
<tr class="odd">
<td align="left"><code>int updateSet[MAXUPDSET]</code></td>
<td align="left">the set of reactants to be updated by the reaction</td>
</tr>
<tr class="even">
<td align="left"><code>double updateOrder[MAXUPDSET]</code></td>
<td align="left"><code>updateOrder[i]</code> gives the amount of reactant change <br> for reactant <code>updateSet[i]</code>.</td>
</tr>
</tbody>
</table>
<p>Note: <code>updateOrder[i], updateOrder[i]</code> together is the ith instance of <code>upd_0~2</code> mentioned in section <a href="#reaction-network-format">Reaction network format</a>.</p>
<h4 id="public-function-members-3"><a href="#public-function-members-3">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">reaction &amp; <span class="kw">operator</span>=(<span class="dt">const</span> reaction &amp; dummy);</code></pre>
<p>The function will copy all values stored in dummy to the current <code>reaction</code> instance and return the pointer of current instance.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> loadReaction(ifstream &amp; reactionFile);</code></pre>
<p>The function member will read 12 values from <code>reactionFile</code>. And store the information in the current <code>reaction</code> instance in a format described in section <a href="#reaction-network-format">Reaction network format</a>. Returned value is the EOF flag of file pointer <code>reactionFile</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> erase()</code></pre>
<p>reset all values in this <code>reaction</code> instance to <code>0</code>.</p>
<h4 id="constructors"><a href="#constructors">constructors</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">reaction()
reaction(<span class="dt">const</span> reaction &amp; dummy)</code></pre>
<p>The default constructor creates a all zero valued instance of <code>reaction</code>. The copy constructor copies all values stored in dummy to the current <code>reaction</code> instance.</p>
<h3 id="trajectory-structure-template"><a href="#trajectory-structure-template">trajectory structure template</a></h3>
<p>defined in &quot;coarseGrainedOperation.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> compType&gt;
<span class="kw">struct</span> trajectory</code></pre>
<p>This structure stores the trajectory of a certain network within a period of time. It is defined before or during a simulation. A saving member is also defined so that the data can be written into file whenever needed.</p>
<h4 id="public-variable-members-2"><a href="#public-variable-members-2">Public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>int nComp</code></td>
<td align="left">number of reactants in the network.</td>
</tr>
<tr class="even">
<td align="left"><code>double * time</code></td>
<td align="left">time points on the trajectory;</td>
</tr>
<tr class="odd">
<td align="left"><code>compType comp</code></td>
<td align="left">storage for number of each reactant at each time point.<br> Format: <code>comp[t*nComp+i]</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>long trajectoryPointer</code></td>
<td align="left">writing pointer, indicate the location to write <br> when using <code>void assign(int, long)</code> to write new data<br> or how many data values to save when using <br> <code>void save(string, bool)</code> to write data to disk.</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-4"><a href="#public-function-members-4">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> append(<span class="dt">double</span> time_alias, compType * comp_alias);</code></pre>
<p>Though it's OK for user to write trajectory data by themselves, this function will append data to the end of the last written data block, and push <code>trajectoryPointer</code> one unit further.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> save( string &amp; outputFileName, <span class="dt">bool</span> append=<span class="dv">1</span>);</code></pre>
<p>Saving the data currently written to the memory block to the point where <code>trajectoryPointer</code> indicates to a file, named with <code>outputFileName</code>. If <code>append=1</code> as default, the data will be appended at the end of the file. While if indicating <code>append=0</code>, the original file will be replaced without warning.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> erase();</code></pre>
<p>This funtion will erase the current assigned memory if exists. <code>trajectoryPointer</code> will also point to 0.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reallocate(<span class="dt">int</span> nComp_alias, <span class="dt">unsigned</span> <span class="dt">long</span> trajectorySize);</code></pre>
<p>Erase(with <code>erase()</code>) currently assigned memory if exists, and reallocate memory for <code>*comp</code> with size<code>nComp_alias*trajectorySize</code>, and <code>*time</code> with size <code>trajectorySize</code>. All values of newly assigned memory will be zero.</p>
<h4 id="constructors-1"><a href="#constructors-1">Constructors</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">trajectory();
trajectory(<span class="dt">int</span> nComp_alias, <span class="dt">unsigned</span> <span class="dt">long</span> trajectorySize_alias);
trajectory(trajectory&lt;compType&gt; &amp; dummy);</code></pre>
<p>Default constructor create an empty <code>trajectory</code> structure. To use, user must first use <code>void reallocate(int nComp_alias, unsigned long trajectorySize)</code> defined as a public function member to allocate memory for the trajectory.</p>
<p><code>trajectory(int nComp_alias, unsigned long trajectorySize_alias);</code> automatically calls <code>void rellocate(int, unsigned long)</code>, thus the datablock will be ready for all operations when this constructor is used.</p>
<p>Copy constructor will create an exact duplicate of dummy <code>trajectory</code>.</p>
<h3 id="coarse-grained-model-class-template."><a href="#coarse-grained-model-class-template.">coarse grained model class template.</a></h3>
<p>defined in &quot;coarseGrainedCommon.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> compType, <span class="kw">typename</span> updRateType&gt;
<span class="kw">class</span> coarseGrainedModel;</code></pre>
<p>This class template defines a basic structure to store information of a coarse grained biochemical network. It also provides basic reaction rate determination method and reactant update method. <code>compType</code> is the type for reactant amounts, can be both <code>int</code> or <code>double</code>. <code>updRateType</code> is the type of <code>* rate</code> used when determining the amount of reactant to be updated. It's suggested to be <code>double</code>. But other variable type is still OK.</p>
<h4 id="public-variable-members-3"><a href="#public-variable-members-3">Public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>int nComp</code></td>
<td align="left">number of different reactants in the network</td>
</tr>
<tr class="even">
<td align="left"><code>compType * comp</code></td>
<td align="left">datablock to store amount of each reactant of current time</td>
</tr>
<tr class="odd">
<td align="left"><code>int nReact</code></td>
<td align="left">number of reactions in the network.</td>
</tr>
<tr class="even">
<td align="left"><code>reaction * react</code></td>
<td align="left">an array to store all reactions in the network.</td>
</tr>
<tr class="odd">
<td align="left"><code>double time</code></td>
<td align="left">current time</td>
</tr>
<tr class="even">
<td align="left"><code>double lastSavedTime</code></td>
<td align="left">last saved time point</td>
</tr>
<tr class="odd">
<td align="left"><code>double stoppingTime</code></td>
<td align="left">time when simulation ends</td>
</tr>
<tr class="even">
<td align="left"><code>double saveTimeInterval</code></td>
<td align="left">time interval between two saving points</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-5"><a href="#public-function-members-5">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">virtual</span> <span class="dt">int</span> modelLoading(string &amp; modelName);</code></pre>
<p>Load model from a folder named <code>modelName</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">int</span> rateDetermine(<span class="dt">double</span> * rate, compType * comp_alias);
    <span class="dt">int</span> rateDetermine(<span class="dt">double</span> * rate);</code></pre>
<p><code>int rateDetermine(double *, compType *)</code> use the reactant information stored in <code>* comp_alias</code> to calculate the reaction rate. Calculated reaction rate is released in array pointed by <code>* rate</code>. For <code>int rateDetermine(double *)</code>, reactant information used is the one pointed by <code>* comp</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> reactantUpdate(compType * comp_alias, <span class="dt">const</span> updRateType * rate);
<span class="dt">int</span> reactantUpdate(<span class="dt">const</span> updRateType * rate);</code></pre>
<p><code>int reactantUpdate(compType *, const updRateType *)</code> will use <code>*rate</code> times the update information stored in each reaction to update reactant amounts stored in <code>* comp_alias</code>. In <code>int reactantUpdate(const updRateType *)</code>, the target reactant amounts storage would be <code>* comp</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset()</code></pre>
<p>Reset data pointed by <code>*comp</code> with the condition loaded from model file. And setting <code>time</code> and <code>lastSavedTime</code> to <code>0</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> assign(<span class="dt">const</span> coarseGrainedModel &amp; dummy)</code></pre>
<p>Duplicate EVERYTHING from the dummy into the current <code>coarseGrainedModel</code>.</p>
<h4 id="constructors-2"><a href="#constructors-2">constructors</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">coarseGrainedModel();
coarseGrainedModel(string &amp; modelName);
coarseGrainedModel(<span class="dt">const</span> coarseGrainedModel&lt;compType, updRateType&gt; &amp; dummy);</code></pre>
<p>Default constructor won't create a workable instance. User need to load a model from file with <code>int modelLoading(string &amp;)</code> before any other operation.</p>
<p><code>coarseGrainedModel(string &amp;)</code> loads a model from file automatically and creates a working instance.</p>
<p>Copy constructor duplicate the dummy <code>coarseGrainedModel</code> into a new instance.</p>
<h3 id="coarse-grained-stochastic-class"><a href="#coarse-grained-stochastic-class">Coarse Grained Stochastic class</a></h3>
<p>defined in &quot;coarseGrainedOperation.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> coarseGrainedStochastic: <span class="kw">public</span> coarseGrainedModel&lt;<span class="dt">int</span>,<span class="dt">double</span>&gt; , 
                               <span class="kw">public</span> gillespie&lt;coarseGrainedStochastic&gt;</code></pre>
<p>This class is based on coarseGrainedModel, using gillespie module for simulation.</p>
<h4 id="public-function-member"><a href="#public-function-member">public function member</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset();
<span class="dt">void</span> assign(<span class="dt">const</span> coarseGrainedStochastic &amp; dummy);</code></pre>
<p>These two function members are inherited from <code>coarseGrainedModel</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simulate(string fileName);</code></pre>
<p>Simulate with gillespie module. The resulting data will be put into a file named by <code>fileName</code>. This is a temporary design, and will be replaced by other modules when multi-thread simulation steps in.</p>
<h4 id="constructor"><a href="#constructor">Constructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">coarseGrainedStochastic(string &amp; modelName, <span class="dt">double</span> stoppingTime_alias,
        <span class="dt">double</span> saveTimeInterval_alias):
    coarseGrainedModel&lt;<span class="dt">int</span>,<span class="dt">double</span>&gt;(modelName), gillespie&lt;coarseGrainedStochastic&gt;
                                               (nReact,
                                                &amp;coarseGrainedModel::rateDetermine,
                                                &amp;coarseGrainedModel::reactantUpdate);
coarseGrainedStochastic(coarseGrainedStochastic &amp; dummy):
    coarseGrainedModel&lt;<span class="dt">int</span>,<span class="dt">double</span>&gt;(dummy),
    gillespie&lt;coarseGrainedStochastic&gt;(nReact,
            &amp;coarseGrainedModel::rateDetermine,
            &amp;coarseGrainedModel::reactantUpdate)</code></pre>
<p>Aside of the behavior inherited from the base classes, the constructors shown above will take <code>stoppingTime</code> and <code>saveTimeInterval</code> information from either user input or <code>dummy</code>.</p>
<h2 id="algorithms"><a href="#algorithms">Algorithms</a></h2>
<p>The following classes are defined as algorithms used for biochemical network related simulation.</p>
<h3 id="outdated-gillespie-algorithmgillespiestandalone"><a href="#outdated-gillespie-algorithmgillespiestandalone">Outdated Gillespie Algorithm(gillespieStandAlone)</a></h3>
<p>defined in &quot;gillespieStandAlone.h&quot; Note: This module used to be called <code>gillespie</code>. However, the stand alone design is outdated and is already replaced by the new <code>gillespie</code> class. Old version is thus changed into <code>gillespieStandAlone</code> for reference purpose.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> gillespieStandAlone: <span class="kw">public</span> BCNetwork&lt;<span class="dt">int</span>, <span class="dt">double</span>, <span class="dt">int</span>&gt;</code></pre>
<p>This class defines both the algorithm and the simulation methods. Gillespie algorithm is an exact simulator for biochemical reactions. Continuum approximation won't work here. Thus the datatype of reactant amounts are integer. So far I didn't see the necessity of seperating them. But when there is a need, they might be seperated in the future.</p>
<h4 id="public-variable-members-4"><a href="#public-variable-members-4">Public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double stoppingTime</code></td>
<td align="left">the stopping signal for the simulation</td>
</tr>
<tr class="even">
<td align="left"><code>long long int savePointInterval</code></td>
<td align="left">the interval of saving points by count of steps</td>
</tr>
<tr class="odd">
<td align="left"><code>long long int nOfNewStep</code></td>
<td align="left">No. of steps since the last saving point</td>
</tr>
<tr class="even">
<td align="left"><code>double saveTimeInterval</code></td>
<td align="left">the interval of saving points measured by time interval</td>
</tr>
<tr class="odd">
<td align="left"><code>double lastSavedTime</code></td>
<td align="left">the time point in which last saving action has taken places.</td>
</tr>
<tr class="even">
<td align="left"><code>bool saveMethod</code></td>
<td align="left">0=save every <code>savePointInterval</code> steps; <br>1=save every saveTimeInterval of time;</td>
</tr>
<tr class="odd">
<td align="left"><code>bool noSave</code></td>
<td align="left">If noSave signal is 1, no data saving is allowed</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-6"><a href="#public-function-members-6">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simulate();</code></pre>
<p>This function will iterate the network with Gillespie algorithm till <code>BCNetwork::t</code> (defined in BCNetwork class template) surpasses <code>stoppingTime</code>. During the simulation, once the saving condition is satisfied, the current time and the current datablock that <code>BCNetwork:: *comp</code> points to will be saved into file specified by <code>BCNetwork::fileOpen(string &amp;)</code>.</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> reset();</code></pre>
<p>This reset function reserves the function of <code>BCNetwork::reset()</code>. It also restore <code>BCNetwork::t</code>, <code>lastSavedTime</code> and <code>nOfNewStep</code> to 0.</p>
<h4 id="constructordestructor-1"><a href="#constructordestructor-1">Constructor/Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">gillespieStandAlone(vector&lt;<span class="dt">int</span>&gt; &amp; initComp, vector&lt;<span class="dt">double</span>&gt; &amp; inputRate,
        <span class="dt">int</span> * inputRateMatrix, <span class="dt">int</span> * inputUpdateMatrix,
        <span class="dt">double</span> runTime ,<span class="dt">bool</span> sMethod=<span class="dv">0</span>, <span class="dt">double</span> saveInterval=<span class="dv">1</span>)</code></pre>
<p>It calls <code>BCNetwork::loadParameter(...)</code> to load a biochemical network. <code>stoppingTime</code> will be determined by <code>runTime</code>, <code>saveMethod</code> will be determined by <code>sMethod</code>. <code>saveInterval</code> will determine the value of either <code>savePointInterval</code> or <code>saveTimeInterval</code> considering which <code>saveMethod</code> user choose.</p>
<h4 id="further-note"><a href="#further-note">Further note</a></h4>
<p>The random number generator used by this class is rand48 given in gcc library. Involved function members are</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> reseedRandom(<span class="dt">int</span> seed);
<span class="kw">inline</span> <span class="dt">double</span> popRandom();</code></pre>
<p>Should other random number generator be used instead the current one. These two member functions can be changed accordingly.</p>
<h3 id="gillespie-algorithm-class-template"><a href="#gillespie-algorithm-class-template">Gillespie Algorithm class template</a></h3>
<p>defined in &quot;gillespie.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> modelClassName&gt;
<span class="kw">class</span> gillespie</code></pre>
<p>This module is built as an stripped version of <code>gillespieStandAlone</code> class. It works the same way as <code>rungeKutta</code> class template. A model using this module must inherit the class template, feed the class template an rate determining function member to <code>int modelClassName::*rateDetermine_alias(double *)</code>. And a reactant updating function member to <code>int (modelClassName::*reactantUpdate_alias)(const double *)</code>. The algorithm performs a single iteration of Gillespie Algorithm, deciding the time step size of the current iteration and which reaction to take place.</p>
<p>Note that</p>
<table>
<thead>
<tr class="header">
<th align="left">Member function name</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>int modelClassName::*rateDetermine_alias(double *)</code></td>
<td align="left">supplied by model, using model's own reactant information<br> to calculate the reaction rate for each reaction.<br> The rate will be pass to the algorithm as a double type pointer<br> given as the function argument.</td>
</tr>
<tr class="even">
<td align="left"><code>int (modelClassName::*reactantUpdate_alias)(const double *)</code></td>
<td align="left">supplied by model, algorithm will pass the number(1 or 0)<br>of each reaction taking places <br> during the time interval as a constant double type pointer.<br> The function member will use the array multiplying<br> the updating part of the reaction. Resulting value<br> will be added onto the current reactant amount<br> stored in model.</td>
</tr>
</tbody>
</table>
<h4 id="public-function-member-1"><a href="#public-function-member-1">Public function member</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> iterate();</code></pre>
<p>The function will do one iteration of algorithm. Reactant amounts will be updated by <code>int reactantUpdate(const double *)</code>, while the time step is to be returned as a double type value.</p>
<h4 id="constructors-3"><a href="#constructors-3">Constructors</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">gillespie();
gillespie(<span class="dt">int</span> reactionNumber_alias, <span class="dt">int</span> (modelClassName::*rateDetermine_alias)(<span class="dt">double</span> *),
        <span class="dt">int</span> (modelClassName::*reactantUpdate_alias)(<span class="dt">const</span> <span class="dt">double</span> *))    </code></pre>
<p>Default constructor does nothing. Not used in most scenario.</p>
<p>The second constructor is what is mostly used when loading with Gillespie algorithm, reaction number and the two function member pointer introduced earlier must be provided when inheriting this algorithm module.</p>
<h3 id="odeivpcommon-class-template"><a href="#odeivpcommon-class-template">ODEIVPCommon Class Template</a></h3>
<p>defined in &quot;ODECommon.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> modelClassType&gt;
<span class="kw">class</span> ODEIVPCommon</code></pre>
<p>This class is a basic class template for all algorithms created for ODE's Initial Value Problem simulation. Currently only Runge-Kutta based simulator is created from it.</p>
<p><code>modelClassType</code> is a typename specified by the models that algorithms are applied upon. It is used by member function pointers of the algorithms for proper scope names.</p>
<h4 id="public-variable-members-5"><a href="#public-variable-members-5">public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double ht</code></td>
<td align="left">current stepsize. For adaptive stepsize algorithms, this value is usually different from <code>ODENetwork::h0</code></td>
</tr>
<tr class="even">
<td align="left"><code>int varNumber</code></td>
<td align="left">number of variables/ODEs.</td>
</tr>
<tr class="odd">
<td align="left"><code>void (modelClassType::*ODEs)(double *, double *)</code></td>
<td align="left">member function pointer. Used to point to ODEs function provided by the specific model.</td>
</tr>
<tr class="even">
<td align="left"><code>int (*Normalizer)(double *)</code></td>
<td align="left">a normalizer, usually need to be specified for each different problem. Thus by definition it's not bound to the member class. Note that this is a function pointer, only static function can be pointed by it.</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-7"><a href="#public-function-members-7">Public function members</a></h4>
<p>N/A</p>
<h4 id="constructordestructor-2"><a href="#constructordestructor-2">Constructor/Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ODEIVPCommon();
ODEIVPCommon(<span class="dt">int</span> sysSize, <span class="dt">double</span> initTimeStep,
        <span class="dt">void</span> (modelClassType::*targetODEs)(<span class="dt">double</span> *, <span class="dt">double</span> *));
ODEIVPCommon(<span class="dt">int</span> sysSize, <span class="dt">double</span> initTimeStep, 
        <span class="dt">void</span> (modelClassType::*targetODEs)(<span class="dt">double</span> *, <span class="dt">double</span> *),
        <span class="dt">int</span> (*targetNormalizer)(<span class="dt">double</span> *));</code></pre>
<p>Three constructors are defined for this class template.</p>
<p>Default constructor does nothing.</p>
<p><code>ODEIVPCommon(int , double, void (modelClassType::*)(double*, double*));</code> is used when no normalizer is required. This constructor will load the first parameter as <code>varNumber</code>, second parameter as the initial value for <code>ht</code>, and third parameter as the address function pointer <code>void (modelClassType::*ODEs)</code> pointing to. Normalizer will be specified to <code>int blankNormalizer(double *)</code> defined in &quot;ODECommon.h&quot;. Normalizer can be otherwisely specified to other functions defined by user afterwards.</p>
<p><code>ODEIVPCommon(int , double, void (modelClassType::*)(double*, double*), int (*)(double *));</code> is used when normalizer is required. First 3 parameters have the same meaning. And the last parameter is used to specify the pointer pointing to the normalizer function.</p>
<h3 id="rkmethod-class-template"><a href="#rkmethod-class-template">RKmethod Class Template</a></h3>
<p>defined in &quot;rungeKutta.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> modelClassType&gt;
<span class="kw">class</span> RKmethod: <span class="kw">public</span> ODEIVPCommon&lt;modelClassType&gt;;</code></pre>
<p>This is an algorithm class template using adaptive stepsize Runge-Kutta method for ODEs simulation of initial value problems. This class will do one thing, and one thing alone. Given current values of all components, their value of next time step and the time interval of current iteration will be returned. Users can implement this algorithm in their model for simulation and do any analysis they want with the returned data.</p>
<p>Note that due to the concern of reliable use of this algorithm, this class is not supposed to be directly modified by any means, thus most functions are kept private.</p>
<h4 id="public-member"><a href="#public-member">Public member</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double hMax</code></td>
<td align="left">maximum stepsize of iteration, <code>hMax=0</code> deactivates the limit.</td>
</tr>
</tbody>
</table>
<p><code>hMax</code> is added for situation where a cap of timestep length is necessary. By default <code>hMax=0</code>, meaning there is no cap value for time step. For any value other than <code>0</code>, the maximum time step will be set to that value. User can change the value of <code>hMax</code> during or after defining an instance of this class template.</p>
<h4 id="public-function-members-8"><a href="#public-function-members-8">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> iterator(<span class="dt">double</span> * var);</code></pre>
<p>This function takes in the datablock storying current value of the variables pointed by <code>* var</code>. New value after one step of iteration will be directly written into the datablock <code>* var</code> pointing to. Time interval for this step of iteration will also be returned as a double value. User can use the time interval to determine the exact time value after this iteration.</p>
<h4 id="constructordestructor-3"><a href="#constructordestructor-3">Constructor/Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RKmethod(maxTimeStep=<span class="dv">0</span>);
RKmethod(<span class="dt">int</span> sysSize, <span class="dt">double</span> initTimeStep,
        <span class="dt">void</span> (modelClassType::*targetODEs)(<span class="dt">double</span> *, <span class="dt">double</span> *), maxTimeStep=<span class="dv">0</span>) :
        ODEIVPCommon&lt;modelClassType&gt;::ODEIVPCommon(sysSize, initTimeStep, targetODEs);
RKmethod(<span class="dt">int</span> sysSize, <span class="dt">double</span> initTimeStep, 
        <span class="dt">void</span> (modelClassType::*targetODEs)(<span class="dt">double</span> *, <span class="dt">double</span> *),  
        <span class="dt">void</span> (*targetNormalizer)(<span class="dt">double</span> *), maxTimeStep=<span class="dv">0</span>): 
        ODEIVPCommon&lt;modelClassType&gt;::ODEIVPCommon(sysSize, initTimeStep,
        targetODEs,targetNormalizer);</code></pre>
<p>The use of the three constructors given by this class template mirror the three constructors of <code>ODEIVPCommon</code>. The first one only initiate the private variables to their working states; Second constructor is used for the case that no normalizer is required; third constructor is used when a normalizer is required for a successful simulation. If a limit of maximum timestep is required, users can change the value of <code>maxTimeStep</code>, whose value will be passed on to <code>hMax</code> during the class initialization.</p>
<h2 id="user-facing-modules-for-biochemical-network-simulation"><a href="#user-facing-modules-for-biochemical-network-simulation">User facing modules for Biochemical Network simulation</a></h2>
<p>Class <code>gillespie</code> described in algorithm classes also falls to this catagory.</p>
<h3 id="odesimulate-class"><a href="#odesimulate-class">ODESimulate Class</a></h3>
<p>defined in &quot;ODEOperation.h&quot;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ODESimulate : <span class="kw">public</span> ODENetwork , <span class="kw">public</span> RKmethod&lt;ODESimulate&gt;</code></pre>
<p>This class use Runge-Kutta algorithm to do simulation on IVP of ODEs defined by ODENetwork.</p>
<h4 id="public-variable-members-6"><a href="#public-variable-members-6">Public variable members</a></h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>type variable_name</code></th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>double stoppingTime</code></td>
<td align="left">the stopping signal for the simulation</td>
</tr>
<tr class="even">
<td align="left"><code>double saveTimeInterval</code></td>
<td align="left">the interval of saving points measured by time interval.</td>
</tr>
<tr class="odd">
<td align="left"><code>double lastSavedTime</code></td>
<td align="left">the time point in which last saving action has taken places.</td>
</tr>
</tbody>
</table>
<h4 id="public-function-members-9"><a href="#public-function-members-9">Public function members</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simulate(string &amp; identifier);</code></pre>
<p>This function will simulate the system and store the result in a file specified by <code>&amp; identifier</code>(it automatically call the function <code>BCNetwork::fileOpen(string &amp;)</code>).</p>
<hr />
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset();</code></pre>
<p>This function retains the function of <code>BCNetwork::reset()</code>. It also restore <code>lastSavedTime</code> to 0. And restore <code>ODEIVPCommon::ht</code> to the value specified by <code>ODENetwork::h0</code>.</p>
<h4 id="constructor-and-destructor-1"><a href="#constructor-and-destructor-1">Constructor and Destructor</a></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ODESimulate(vector&lt;<span class="dt">double</span>&gt; &amp; initComp, vector&lt;<span class="dt">double</span>&gt; &amp; inputRate,
        <span class="dt">int</span> * inputRateMatrix, <span class="dt">int</span> * inputUpdateMatrix, 
        <span class="dt">double</span> initTimeStep, <span class="dt">double</span> runTime, <span class="dt">double</span> saveInterval) :
        ODENetwork(initComp, inputRate, inputRateMatrix, inputUpdateMatrix,
        initTimeStep), RKmethod&lt;ODESimulate&gt;(nComp, h0, &amp;ODESimulate::ODETimeDeri);</code></pre>
<p>Notice that no default constructor is defined. This constructor will load a typical biochemical network, and call the constructor of <code>RKmethod</code> that doesn't use normalizer. Two additional information is loaded to specify <code>stoppingTime</code> and <code>saveTimeInterval</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    stoppingTime=runTime;
    saveTimeInterval=saveInterval;</code></pre>
</body>
</html>
